#include <iostream>
#include <string>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include "data.pb.h" // Generated by Protobuf compiler

class UdsClient {
private:
    int socket_fd;
    struct sockaddr_un addr;
    std::string socket_path;

public:
    UdsClient(const std::string& path) : socket_path(path) {
        socket_fd = socket(AF_UNIX, SOCK_STREAM, 0);
        if (socket_fd == -1) {
            perror("socket");
            exit(EXIT_FAILURE);
        }

        memset(&addr, 0, sizeof(addr));
        addr.sun_family = AF_UNIX;
        strncpy(addr.sun_path, socket_path.c_str(), sizeof(addr.sun_path) - 1);

        if (connect(socket_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
            perror("connect");
            close(socket_fd);
            exit(EXIT_FAILURE);
        }
    }

    ~UdsClient() {
        close(socket_fd);
    }

    bool sendRequest(const std::string& type, const std::string& key, dev::jasser::configDaemon::UdsResponse& response) {
        dev::jasser::configDaemon::UdsRequest request;
        request.set_type(type);
        request.set_key(key);

        // Serialize request
        std::string request_data;
        request.SerializeToString(&request_data);

        // Send request
        if (send(socket_fd, request_data.c_str(), request_data.size(), 0) == -1) {
            perror("send");
            return false;
        }

        // Receive response
        char buffer[2048];
        ssize_t bytes_received = recv(socket_fd, buffer, sizeof(buffer), 0);
        if (bytes_received == -1) {
            perror("recv");
            return false;
        }

        google::protobuf::io::CodedInputStream coded_stream(reinterpret_cast<const uint8_t*>(buffer), bytes_received);
        if (!response.ParseFromCodedStream(&coded_stream)) {
            std::cerr << "Failed to parse response." << std::endl;
            return false;
        }

        return true;
    }

    void subscribeToConfigChange(std::function<void(const std::string&)> callback) {
        // For subscription, we can continuously listen for updates.
        // This can be done in a loop or using a background thread.
        while (true) {
            dev::jasser::configDaemon::UdsResponse response;
            if (sendRequest("SUBSCRIBE", "", response)) {
                if (response.statusCode() == 200) {
                    std::cout << "Subscribed successfully. Waiting for updates..." << std::endl;
                } else {
                    std::cerr << "Subscription failed." << std::endl;
                }
            }

            // Here we simulate waiting for updates and trigger the callback.
            // In a real implementation, you would likely have a separate thread for reading responses.
            callback(response.value());
        }
    }
};